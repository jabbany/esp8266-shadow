/* 
  esp8266-shadowsocks

  Note: Please only configure options in config.h
  See LICENSE for license information
*/
#include <ESP8266WiFi.h>
#include "credentials.h"
#include "config.h"

/** DO NOT EDIT THIS FILE. USE CREDENTIALS **/
#include "ssimpl.h"
#include "logger.hpp"

#include "proto.hpp"

#define Min(a,b) ((a) > (b) ? (b) : (a))
#define Max(a,b) ((a) > (b) ? (a) : (b))

WiFiServer server(SS_SERVER_PORT);
WiFiClient local[SS_MAX_CONNECTIONS];
WiFiClient remote[SS_MAX_CONNECTIONS];
SSConnection connections[SS_MAX_CONNECTIONS];

// Global buffer for copying stuff. This is safe since single threaded
uint8_t buf[BUFFER_SIZE];

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_password);

  Serial.print("\nConnecting to "); 
  Serial.println(wifi_ssid);
  uint8_t i = 0;
  while (WiFi.status() != WL_CONNECTED && i++ < WIFI_WAIT_COUNT) {
    delay(WIFI_WAIT_DELAY);
    Serial.print(".");
  }
  Serial.println("");
  if(i >= WIFI_WAIT_COUNT){
    Serial.print("Could not connect! Halting."); 
    while(1) {
      // Halt the device
      delay(500);
    }
  }

  server.begin();
  server.setNoDelay(true);

  // Initialize
  for (i = 0; i < SS_MAX_CONNECTIONS; i++) {
    connections[i].localState = LOCAL_RESET;
    connections[i].remoteState = REMOTE_RESET;
  }

  if (SS_PRINT_CONFIG) {
    show_config(SS_SERVER_PORT);
  }
  Serial.flush();
  s_log(LOG, F("Awaiting clients..."), 0);
}

void pipe(WiFiClient *source, WiFiClient *target) {
  #if BUFFER_SIZE == 0
    target->write(*source);
    yield();
  #else
    size_t src_size = source->available();
    #if LIMIT_TO_BUFFER == 1
      source->readBytes(buf, Min(BUFFER_SIZE, src_size));
      target->write(buf, Min(BUFFER_SIZE, src_size));
      target->flush();
      yield();
    #else
      if (src_size <= BUFFER_SIZE) {
        source->readBytes(buf, src_size);
        target->write(buf, src_size);
        target->flush();
        yield();
      } else {
        while (src_size > 0) {
          source->readBytes(buf, Min(BUFFER_SIZE, src_size));
          target->write(buf, Min(BUFFER_SIZE, src_size));
          src_size -= Min(BUFFER_SIZE, src_size);
          yield();
        }
        target->flush();
      }
    #endif
  #endif
}

void loop() {
  uint8_t i;
  // Event loop, check for new clients
  if (server.hasClient()){
    for (i = 0; i < SS_MAX_CONNECTIONS; i++){
      if (!local[i].connected()){
        if (local[i]) {
          local[i].stop();
        }
        if (remote[i]) {
          remote[i].stop();
        }
        connections[i].localState = LOCAL_RESET;
        connections[i].remoteState = REMOTE_RESET;
        local[i] = server.available();
        #if SS_ENCRYPTION == 0
        connections[i].localState = LOCAL_READY;
        #endif
        #if SS_ENCRYPTION == 1
        connections[i].localState = LOCAL_AWAIT_GREETING;
        #endif
        #if SS_ENCRYPTION == 2
        connections[i].localState = LOCAL_AWAIT_GREETING;
        #endif
        #if SS_ENCRYPTION >= 10
        connections[i].localState = LOCAL_AWAIT_IV;
        #endif
        s_log(LOG, F("Client connected"), i);
        break;
      }
    }
    // Not enough resources
    if (i >= SS_MAX_CONNECTIONS) {
       WiFiClient newClient = server.available();
       newClient.stop();
       s_log(WARN, F("Out of resources."), i);
    }
    yield();
  }

  // Event loop
  for(i = 0; i < SS_MAX_CONNECTIONS; i++){
    if (connections[i].localState != LOCAL_RESET) {
      // Local service is connected

      if (!local[i].connected()) {
        connections[i].localState == LOCAL_RESET;
        continue;
      }

      if (local[i].available()) {
        // There is data being sent to us

        if (connections[i].localState == LOCAL_COMPLETE) {
          connections[i].remoteState = remote[i].connected() ? REMOTE_CONNECTED : REMOTE_RESET;
          if (connections[i].remoteState == REMOTE_CONNECTED) {
            pipe(&local[i], &remote[i]);
          } else {
            // Remote state is disconnected, is it really?
            s_log(WARN, F("Remote closed. Reset Local."), i);
            connections[i].remoteState = REMOTE_RESET;
            connections[i].localState = LOCAL_RESET;
            local[i].stop();
          }
        } else {
          // Negotiate the protocol

          #if SS_ENCRYPTION == 2
          negotiate_socks5(&local[i], &connections[i], i);
          #else
          s_log(WARN, F("No negotiation protocol"), i);
          #endif
          yield();

          if (connections[i].localState == LOCAL_READY) {
            r_log(connections[i].addrType, 
              (char*) connections[i].host, 
              connections[i].port,
              i);
            switch(connect_remote(&remote[i], &connections[i])) {
              case RC_SUCCESS:
                s_log(LOG, F("Success"), i);
                #if SS_ENCRYPTION == 2
                local[i].write(_socks_connection_success, 10);
                local[i].flush();
                #endif
                connections[i].localState = LOCAL_COMPLETE;
                connections[i].remoteState = REMOTE_CONNECTED;
                break;
              case RC_HOST_UNREACHABLE:
                s_log(LOG, F("Host unreachable."), i);
                #if SS_ENCRYPTION == 2
                local[i].write(_socks_connection_fail, 10);
                close_local(&local[i], &connections[i]);
                connections[i].remoteState = REMOTE_RESET;
                #endif
                break;
              case RC_ADDR_TYPE_NOT_SUPPORTED:
                s_log(LOG, F("Addr unsupported."), i);
                #if SS_ENCRYPTION == 2
                local[i].write(_socks_connection_fail, 10);
                close_local(&local[i], &connections[i]);
                connections[i].remoteState = REMOTE_RESET;
                #endif
                break;
              default:
                s_log(LOG, F("Unknown failure."), i);
                #if SS_ENCRYPTION == 2
                local[i].write(_socks_connection_fail, 10);
                close_local(&local[i], &connections[i]);
                connections[i].remoteState = REMOTE_RESET;
                #endif
                break;
            }
          }
        }
        // Yield to WiFi
        yield();
      }

      if (connections[i].remoteState == REMOTE_CONNECTED && remote[i].available()) {
        // Remote is connected
        if (!local[i] || !local[i].connected()){
          s_log(WARN, F("Local closed. Discarding remote data."), i);
          connections[i].localState = LOCAL_RESET;
          connections[i].remoteState = REMOTE_RESET;
          remote[i].stop();
        } else {
          pipe(&remote[i], &local[i]);
        }
      }
    } else {
      // The local service is not connected or was disconnected.
      connections[i].localState = LOCAL_RESET;

      if (connections[i].remoteState != REMOTE_RESET && remote[i] && remote[i].connected()) {
        // There is still an active remote for the current local service
        connections[i].remoteState = REMOTE_RESET;
        remote[i].stop();
        s_log(LOG, F("Local closed. Reset Remote."), i);
      }
    }
  }
  delay(1);
}
