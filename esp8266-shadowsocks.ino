/* 
  esp8266-shadowsocks

  See LICENSE for LICENSE information
*/
#include <ESP8266WiFi.h>
#include "config.h"


/** DO NOT EDIT THIS FILE. USE CREDENTIALS **/
#include "ssimpl.h"

WiFiServer server(SS_SERVER_PORT);
WiFiClient local[SS_MAX_CONNECTIONS];
WiFiClient remote[SS_MAX_CONNECTIONS];
SSConnection connections[SS_MAX_CONNECTIONS];

// Global buffer for copying stuff.
// TODO(safety): This is actually OK since we're single threaded!
uint8_t buf[BUFFER_SIZE];

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin(wifi_ssid, wifi_password);

  Serial.print("\nConnecting to "); 
  Serial.println(wifi_ssid);
  uint8_t i = 0;
  while (WiFi.status() != WL_CONNECTED && i++ < WIFI_RETRY_COUNT) {
    delay(WIFI_RETRY_DELAY);
    Serial.print(".");
  }
  Serial.println("");
  if(i >= WIFI_RETRY_COUNT){
    Serial.print("Could not connect to "); 
    Serial.println(wifi_ssid);
    while(1) {
      // Halt the device
      delay(500);
    }
  }

  server.begin();
  server.setNoDelay(true);

  if (SS_PRINT_CONFIG) {
    Serial.print("Shadowsocks Server listening at ");
    Serial.print(WiFi.localIP());
    Serial.print(":");
    Serial.println(SS_SERVER_PORT, DEC);
  } else {
    Serial.println("Shadowsocks Server is listening");
  }
  Serial.println("LOG: Awaiting clients");
}

void pipe(uint8_t i, uint8_t transferDir) {
  WiFiClient source;
  WiFiClient target;
  if (transferDir == 0) {
    source = local[i];
    target = remote[i];
  } else {
    source = remote[i];
    target = local[i];
  }
  if (source.available() <= BUFFER_SIZE) {
    size_t src_size = source.available();
    source.readBytes(buf, src_size);
    target.write(buf, src_size);
  } else {
    size_t src_size = source.available();
    while (src_size > 0) {
      source.readBytes(buf, min(BUFFER_SIZE, src_size));
      target.write(buf, min(BUFFER_SIZE, src_size));
      src_size -= min(BUFFER_SIZE, src_size);
    }
  }
}

void loop() {
  uint8_t i;
  // Event loop, check for new clients
  if (server.hasClient()){
    for (i = 0; i < SS_MAX_CONNECTIONS; i++){
      if (!local[i] || !local[i].connected()){
        if (local[i]) {
          local[i].stop();
        }
        local[i] = server.available();
        Serial.print("LOG: New connection established at slot ");
        Serial.println(i);
        break;
      }
      yield();
    }
    // Not enough resources
    if (i >= SS_MAX_CONNECTIONS) {
       WiFiClient newClient = server.available();
       newClient.stop();
       Serial.println("WARN: Connection rejected. Out of resources.");
    }
  }
  // Event loop
  for(i = 0; i < SS_MAX_CONNECTIONS; i++){
    if (local[i] && local[i].connected()) {
      // Check if there's data from local that needs to be sent to remote
      if (local[i].available()){
        // There is data being sent to us. Check if we are in forwarding mode
        if (remote[i].connected()) {
          if (connections[i].remoteState == REMOTE_CONNECTED) {
            // Forward all the local stuff to the remote
            pipe(i, 0);
          } else {
            // Do other stuff. Technically if remote is connected state should be connected
            connections[i].remoteState = REMOTE_CONNECTED;
          }
        } else {
          if (connections[i].remoteState == REMOTE_RESET) {
            // Negotiate the remote
            if (SS_ENCRYPTION == 0) {
              // Shadow protocol but with no encryption
              
            } else if (SS_ENCRYPTION == 1) {
              // Socks5 protocol
              
            } else {
              char* host = "koukuko.com"; // example domain
              int port = 80;
              if (!remote[i].connect(host, port)) {
                // Remote connection failed, also kill the local
                Serial.print("WARN: Could not establish connection to");
                Serial.print(host);
                Serial.print(":");
                Serial.println(port);
                connections[i].remoteState = REMOTE_RESET;
                local[i].stop();
              } else {
                // Print success message, defers sending of any actual data to next round
                Serial.print("LOG: Successful connection to ");
                Serial.println(host);
                connections[i].remoteState = REMOTE_CONNECTED;
              }
            }
          } else {
            Serial.println("LOG: Remote closed connection");
            connections[i].remoteState = REMOTE_RESET;
            local[i].stop();
          }
        }
        // Yield to WiFi
        yield();
      }

      // Check if there's data from remote that needs to be sent to local
      if (remote[i] && remote[i].connected()) {
        if (remote[i].available()) {
          // Forward any remote content to local
          pipe(i, 1);

          // Yield to WiFi
          yield();
        }
      }
    } else {
      if (remote[i] && remote[i].connected() && connections[i].remoteState != REMOTE_RESET) {
        remote[i].stop();
        connections[i].remoteState = REMOTE_RESET;
        Serial.print("LOG: Local connection was closed. Closing remote ");
        Serial.println(i);
      }
    }
  }
  delay(1);
}
